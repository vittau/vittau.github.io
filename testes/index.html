<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>CAPGov - Testes</title>

		<meta name="description" content="Slides sobre testes">
		<meta name="author" content="Vitor Machado">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/league.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Testes</h1>
					<h3>Centro de Apoio à Políticas de Governo</h3>
					<img src="img/capgov.png" />
					<p>
						<small>Slides por <a href="http://vittau.github.io">Vitor Machado</a></small>
					</p>
				</section>

				<section>
					<h2>Motivação</h2>
					<p>
						<ul>
							<li>
								Testes não resultam diretamente em um retorno de investimento (ROI), mas sim de custo X benefício do projeto:
								<ul>
									<li>Utilização dos testes resulta em um aumento de qualidade e confiabilidade do software desenvolvido;</li>
								</ul>
							</li>
							<li>Os testes podem ser vistos como um indicador palpável do quão robusto o sistema está.</li>
						</ul>
					</p>
				</section>

				<section>
					<h2>Refatoramento</h2>
					<p>
						<ul>
							<li>
								A existência de testes facilita a prática do refatoramento:
								<ul>
									<li>Quando um refatoramento é realizado e todos os testes já existentes permanecem bem-sucedidos, pode-se acreditar com alto grau de confiabilidade que o refatoramento de fato não alterou nenhum comportamento externo da funcionalidade.</li>
								</ul>
							</li>
						</ul>
					</p>
					<img src="img/TDD.png" height="250px" />
				</section>

				<section>
					<h2>Testes como documentação</h2>
					<p>
						<ul>
							<li>
								Testes podem ainda funcionar como uma documentação viva, que se mantém atualizada desde que os testes sejam mantidos em funcionamento:
								<ul>
									<li>Indicam diretamente as funcionalidades do código e comportamentos esperados.</li>
								</ul>
							</li>
						</ul>
					</p>
					<img src="img/TestesDoc.png" />
				</section>

				<section>
					<h2>Testes unitários</h2>
					<p>
						<ul>
							<li>
								São testes cujo foco está em uma única "unidade" de código:
								<ul>
									<li>Visam testar as menores partes possíveis do código, englobando apenas uma funcionalidade por teste;</li>
									<li>Esses testes devem ser totalmente independentes de outras áreas do sistema, por tanto devem ser usados "mocks" e "stubs" (objetos simulados) para isolar um teste de outras partes do sistema.</li>
								</ul>
							</li>
							<li>Normalmente são desenvolvidos pelos próprios desenvolvedores do sistema, muitas vezes antes de escrever o próprio código do sistema (método chamado de "test-driven development" ou TDD).</li>
						</ul>
					</p>
				</section>

				<section>
					<h2>Testes de integração</h2>
					<p>
						<ul>
							<li>
								São testes cujo foco está na interoperabilidade de dois ou mais módulos de funcionalidade do sistema:
								<ul>
									<li>Diversas vezes unidades funcionam corretamente em isolamento, mas apresentam falhas quando utilizadas juntas;</li>
								</ul>
							</li>
							<li>São desenvolvidos em quantidade menor que os testes unitários, e normalmente numa etapa posterior.</li>
							<li>Esses testes normalmente são desenvolvidos pelos próprios desenvolvedores assim como os testes unitários, e também podem ser utilizados com metodologia TDD.</li>
						</ul>
					</p>
				</section>

				<section>
					<h2>Testes unitários - boas práticas</h2>
					<p>
						<ul>
							<li>
								Testes consistem de asserções sobre resultados obtidos, comparando-os com resultados esperados:
								<ul>
									<li>O ideal é que cada teste contenha apenas uma única asserção, ou o mínimo possível;</li>
									<li>Muitas asserções por teste dificultam a localização da causa da falha;</li>
								</ul>
							</li>
							<li>
								Testes unitários devem ser isolados do resto do sistema, para isso devem ser utilizados mocks ou stubs para simular o comportamento de outras partes do código:
								<ul>
									<li>A ferramenta PowerMock (Java) possibilita a criação de mocks para qualquer método, incluindo métodos estáticos.</li>
								</ul>
							</li>
						</ul>
					</p>
				</section>

				<section>
					<h2>Testes unitários - métricas</h2>
					<p>
						<ul>
							<li>
								A métrica mais comumente utilizada para testes unitários é a cobertura de código, facilitando a localização de partes não testadas do código:
								<ul>
									<li>A ferramenta EclEmma (Eclipse) pode ser utilizada para ver a porcentagem de código coberta por testes.</li>
								</ul>
							</li>
						</ul>
					</p>
				</section>

				<section>
					<h2>Testes de integração - boas práticas</h2>
					<p>
						<ul>
							<li>
								Os testes de integração cobrem múltiplas partes do sistema, e por isso não haverá o mesmo nível de isolamento:
								<ul>
									<li>Ainda assim, partes do sistema fora do escopo do teste devem ser isoladas;</li>
								</ul>
							</li>
							<li>São escritos em um nível mais alto e devem refletir de maneira ainda mais direta os requisitos de software.</li>
						</ul>
					</p>
					<h2>Testes de integração - métricas</h2>
					<p>
						<ul>
							<li>
								Assim como nos testes unitários a métrica mais comum é a cobertura de código.
							</li>
						</ul>
					</p>
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

		<!-- Google Analytics -->
		<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
		ga('create', 'UA-71214783-2', 'auto');
		ga('send', 'pageview');
		</script>
	</body>
</html>